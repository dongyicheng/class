<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
<script>
    //unique
    var ary = [12, 23, 23, 5, 6, 7, 12]

    // function unique(ary) {
    //     let obj = {};
    //     //循环数组 判断数组这一项 在不在原来的对象中
    //     //在就删除  不在就添加到obj中
    //     for (let i = 0; i < ary.length; i++) {
    //         if (obj.hasOwnProperty(ary[i])) {
    //             ary.splice(i, 1);
    //             i--;
    //         } else {
    //             obj[ary[i]] = ary[i];
    //         }
    //     }
    //     return ary;
    // }
    // console.log(unique(ary));
    //
    //
    Array.prototype.myUnique=function myUnique() {
        let obj = {};
        //循环数组 判断数组这一项 在不在原来的对象中
        //在就删除  不在就添加到obj中
        for (let i = 0; i < this.length; i++) {
            if (obj.hasOwnProperty(this[i])) {
                this.splice(i, 1);
                i--;
            } else {
                obj[this[i]] = this[i];
            }
        }
        return this;
    };
    // ary.myUnique();
    // console.log(ary);
    //
    //
    // var arr=ary.reverse();
    // var ary=ary.reverse().pop();

   //这种能通过连续打点的方式调用的方式, 称为链式调用;
    //实现链式调用的关键  是看返回值  是否仍为该类的一个实例
    //若每个函数返回值都是this ; 那我们就能实现连续的链式调用



    Array.prototype.myPush=function myPush(n) {
        this[this.length] = n;
        return this;
    };
    Array.prototype.myPop=function myPop() {
        this.length--;
        return this;
    };
    var arr2=ary.myUnique().myPush(12).myPush(14).myPop().myPop().myPush(14).myUnique();
    console.log(arr2);



    //12+12-10
    Number.prototype.add=function add(n) {
        return this + n;
    };
    Number.prototype.minus=function minus(n){
        return this - n;
    };
    var a=12;
    console.log(a.add(12).minus(10));
</script>